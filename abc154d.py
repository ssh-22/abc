"""
N個のサイコロの左からi番目のサイコロは1からpiまでのpi種類の目が等確率で出る
隣接するK個のサイコロを選んでそれぞれ独立に振ったとき、出る目の合計の期待値の最大値を求める

https://atcoder.jp/contests/abc154/tasks/abc154_d

1. 期待値のリストを作る
2. 累積和を計算する
3. K個のサイコロについて区間和を計算し、より大きいものを答えとして更新する
    1. 0 ~ 0+K-1番目までの区間和 = 0+K-1番目までの累積和
    2. i番目から i+K-1番目までの区間和 = i+K-1番目までの累積和 - i-1番目までの累積和
"""
N, K = map(int, input().split())
P = []
for p in list(map(int, input().split())):
    P.append(p * (1+p) / (p*2))
S = [P[0]]
for i in range(1, N):
    S.append(S[i-1] + P[i])
ans = 0
# K個のサイコロについて区間和を計算する(N-K+1)
# N=5, K=3, [1,2,3,4,5] -> [1,2,3] [2,3,4] [3,4,5] -> 0,1,2
# N=5, K=2, [1,2,3,4,5] -> [1,2] [2,3] [3,4] [4, 5] -> 0,1,2,3
# N=5, K=1, [1,2,3,4,5] -> [1] [2] [3] [4] [5] -> 0,1,2,3,4
for i in range(N-K+1):
    if i == 0:
        # 0 ~ 0+K-1番目までの区間和 = 0+K-1番目までの累積和
        # 0 ~ 2番目までの区間和 = 2番目までの累積和
        ans_tmp = S[i+K-1]
    else:
        # i番目から i+K-1番目までの区間和 = i+K-1番目までの累積和 - i-1番目までの累積和
        # 1番目から3番目までの区間和 = 3番目までの累積和 - 0番目までの累積和
        ans_tmp = S[i+K-1] - S[i-1]
    ans = max(ans, ans_tmp)
print(ans)